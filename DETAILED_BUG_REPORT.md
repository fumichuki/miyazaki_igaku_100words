# 詳細バグレポート：文法・表現のポイント解説の項目数問題（N対応版）

以下、**agent にそのまま貼り付けて使える「問題点の詳細記載（＝バグレポート）」**です。
※今回の対象は **「💡 文法・表現のポイント解説」(= front の nonEvaluationPoints に出る部分)** の実装のみ。ここは作り直してOK。

---

## 0. 目的（今回"問題点として"確定させたいこと）

* **日本語N文**（原文）に対し、UIに表示される **「💡 文法・表現のポイント解説」= N項目** が安定して出ること

  * UIは `level !== "内容評価"` の件数を「〜項目」として表示している（static/main.js:482-485）。
  * **N（required_points）は入力から自動決定する**（後述の決定ルール参照）
* **文数ズレケース**も正しく扱うこと

  1. 日本語5文に対してユーザーが英文3文で提出（要約・統合）→ required_points=5（原文基準）
  2. 日本語2文分を `, which ...` 等で **英文1文に統合**して提出 → required_points=2（原文基準）
  3. 原文が無い場合 → 学生英文の文数を required_points とする
* いずれの場合も **ユーザーが納得する「理由（解説）」の品質**（語彙比較＋【参考】＋例文2つ）が担保されること。

### required_points（必要項目数）の決定ルール

以下の優先順位で required_points を一意に決める：

1. **原文（日本語）の文数を取得できるなら、それを required_points とする**
   - 例：原文5文 → required_points=5
   - 学生が要約して3文で提出しても、required_points=5を維持
   - 各pointのreason内で「統合している」旨を説明
   
2. **原文が無い／解析不能なら、学生英文の文数を required_points とする**
   - 例：原文なし、学生3文 → required_points=3
   - ピリオド区切りで文数をカウント
   
3. **それも曖昧なら、意味単位（proposition）数を required_points とする**
   - LLMに「この英文は何個の主張を含むか」を判定させる
   - 最終手段として使用

---

## 1. 現象（再現する症状）

### 1-1. 画面上の表示

以下のように **ポイント解説が 1項目しか出ず**、しかも中身が固定文言の「エラー」になる。

```
💡 文法・表現のポイント解説（1項目）
1
💡 学生の表現
→
✅ より良い表現
添削処理中にエラーが発生しました。再度お試しください。
```

※重要：これは"本当の例外"ではなく、**バックエンドが`len(points) < required_points`を満たさない場合に差し込んでいる固定フォールバック文言**。

### 1-2. N不足の根本原因

required_pointsがN（原文または学生英文の文数）であるべきなのに、以下の理由で1項目になる：

1. **LLMが少数のpointsしか返さない**（プロンプトがN個を強制していない）
2. **現状：`len(points) < 3`という固定閾値**でエラー判定し、pointsを1件に置換
   - **N対応後：`len(points) < required_points`に変更すべき**
3. **before空のpointを除外**した結果、さらに項目数が減る
4. **不足時の埋め合わせ処理が無い**ため、常に1項目で固定される

---

## 2. UI側の仕様（= バックエンドが満たすべき前提）

### 2-1. 項目数のカウント方法

* UIは `data.points.filter(p => p.level !== "内容評価").length` を数えて
  `💡 文法・表現のポイント解説（N項目）` と表示している（static/main.js:482-485）。
* つまり **非「内容評価」point が N個あれば N項目**になる。
* **Nは動的に変わる**（原文3文なら3項目、5文なら5項目）

### 2-2. 「内容評価」point の扱い

* UIは `data.points.find(p => p.level === "内容評価")` がある場合だけ「全体評価」を表示する（static/main.js:420-478）。
* バックエンドが **「内容評価」point を返さない設計**でもUIは落ちないが、
  **全体評価は常に出すのが理想**（required_points + 1件）。

---

## 3. バックエンド側の"確定している"問題点（コード根拠つき）

対象ファイル：`llm_service.py`

### 3-1. points が required_points 未満で「固定のエラーポイント1件」に強制置換される

* `llm_service.py:1241-1249` にて、次の条件で points が丸ごと置換される：

```python
if 'points' not in correction_data or len(correction_data['points']) < 3:
    correction_data['points'] = [{
        "before": "学生の表現",
        "after": "より良い表現",
        "reason": "添削処理中にエラーが発生しました。再度お試しください。",
        "level": "💡改善提案"
    }]
```

**問題点（N対応の観点から）**

1. **固定閾値3**：N文の場合、required_points=Nであるべきだが、`< 3`という固定値で判定している
   - N=5なら5項目必要だが、4項目返っても`< 3`に引っかからず素通りし、結果的にN不足
   - N=2なら2項目で十分だが、`< 3`に引っかかり不要なエラー置換が発生
   
2. **破壊的な置換**：LLMが2個の有益なpointsを返していても、丸ごと1件のエラーに置換される
   - 既存のpointsが全て失われる
   - 「不足分を埋める」ではなく「全部捨てる」という設計
   
3. **1件固定**：置換後は必ず1項目になり、UIの表示が崩れる
   - required_pointsがいくつであろうと、常に1項目

4. **エラー誤表示**：実際は添削できているのに「エラーが発生しました」と表示される

> 結論：`len(points) < required_points`という**動的な不足検出**に変更し、**不足時は埋め合わせ（fill）処理**が必要。

---

### 3-2. 「before が空」な point は除外され、結果として項目数が減る（しかも再補完が無い）

* `llm_service.py:1251-1270` で、before が空だとスキップして `valid_points` のみにする。

```python
valid_points = []
for point in correction_data['points']:
    if point.get('before', '').strip():
        valid_points.append(point)
correction_data['points'] = valid_points
```

**問題点（N対応の観点から）**

1. **N不足の原因**：LLMが5個返しても、1個だけbeforeが空だと4個に減る
   - required_points=5なのに、4個しか残らない
   - フィルタ後に「N不足か？」の再検証が無い
   
2. **埋め合わせ処理が無い**：除外後、不足分を補う処理が存在しない
   - 4個に減った時点で確定し、UIには4項目として表示される
   
3. **連鎖的なN不足**：除外 → N不足 → 3-1の置換トリガ発動 → 1項目エラー

> 結論：before空除外は必要だが、除外後に`len(valid_points) < required_points`を検出し、**不足分を埋める再プロンプト処理**が必要。

---

## 4. プロンプト側の"仕様ズレ"が points の少数出力を誘発している

対象：`prompts_translation_simple.py`

### 4-1. points の個数を「最低1個」としか要求していない（N個の強制が無い）

* プロンプト内に「points は最低1個以上」とあるが、**N個を強制する指示が無い**。
  
**問題点（N対応の観点から）**

1. **Nが指定されていない**：「原文N文に対してN個のpointsを返せ」という要求が無い
   - LLMは1個だけ返すのが仕様上許容される
   - required_points=5でも、1個しか返さない可能性がある
   
2. **N不足の根本原因**：プロンプトがN個を要求していないため、バックエンドで埋め合わせるしかない
   - 本来はプロンプトで「必ずN個返せ」と指示すべき
   - それでも不足する場合のみ、バックエンドで再プロンプト

> 修正方針：プロンプトに `required_points=N` をパラメータとして渡し、「必ずN個の非「内容評価」pointを返せ」と明示する。

---

### 4-2. level の仕様も不統一（prompt と backend fallback が矛盾）

* prompt は level を「✅/❌のみ（💡は使わない）」と書いている一方、
  backend の置換は level="💡改善提案" を返す。
* UIは level文字列を見て表示を変える実装があるため、**この不一致は UI 表示の不安定要因**。

> 修正方針：levelの値を統一する（✅正しい表現 / ❌文法ミス / 💡改善提案 / 内容評価）。

---

## 5. 文数ズレケースの扱い（required_points 決定ルールで一意に決まる）

### 5-1. 基本方針

文数ズレ（要約・統合）が発生しても、**required_points 決定ルール**（0章参照）に従うため、挙動は一意に決まる。

| ケース | 原文 | 学生英文 | required_points | 理由 |
|--------|------|----------|-----------------|------|
| 標準 | 4文 | 4文 | 4 | 原文基準（ルール1） |
| 要約 | 5文 | 3文 | 5 | 原文基準（ルール1） |
| 統合 | 4文 | 2文 | 4 | 原文基準（ルール1） |
| 原文なし | なし | 3文 | 3 | 学生英文基準（ルール2） |

### 5-2. 要約ケース（原文N文 → 学生M文、M < N）

* 例：原文5文 → 学生3文（要約）
* **required_points = 5**（原文基準）
* **挙動**：
  - バックエンドは5個のpointsを要求
  - 各pointのreason内で「複数文を統合している」旨を説明
  - 例：「1文目は原文1-2文目の内容を統合しています」
  
### 5-3. 統合ケース（原文2文 → 学生1文、関係節/分詞構文）

* 例：日本語2文 → 英文1文（`, which ...`で統合）
* **required_points = 2**（原文基準）
* **挙動**：
  - バックエンドは2個のpointsを要求
  - 1個目：前半部分の解説
  - 2個目：関係節/分詞部分の解説
  - 各reason内で「統合された英文の前半/後半」と明示

### 5-4. 原文なしケース

* 例：原文解析不能、学生3文
* **required_points = 3**（学生英文基準）
* **挙動**：
  - ピリオド区切りで学生英文を分解し、文数をカウント
  - その数をrequired_pointsとする

---

## 6. ユーザーが求める「解説品質」の要件（reason の中身）

今回の "文法・表現のポイント解説" は、下記の形式（語彙比較＋【参考】＋例文2つ）を満たす必要がある。
（= ここが満たせないなら、出力がN項目でもユーザー満足が出ない）

### 必須要素（各pointのreasonに含める）

1. **英文（対象文）**：学生が書いた英文そのまま
2. **日本語訳**：（括弧内）に記載
3. **語彙・表現の比較**：`A（品詞：意味：文脈）／B（…）で違い説明`
4. **【参考】**：文法パターンや使い分けのヒント
5. **例文2つ**：英文＋日本語訳をセットで2つ

### 解説フォーマット例

```
N文目: The participants were divided into two groups.
（参加者は2つのグループに分けられた。）
divide（動詞：分ける・分割する：物や人を複数に分ける文脈）／split（動詞：分割する・分裂する：より具体的に分ける動作の文脈）で、divideは一般的な分割を示し、splitはしばしば物理的に分けることを指します。
【参考】divide A into B（AをBに分ける）／split A into B（AをBに分ける）
例：The teacher divided the class into two groups.「先生はクラスを2つのグループに分けた。」／They split the class into two groups.「彼らは（ぱっと）クラスを2つに分けた。」
```

> **重要**：この品質要件を満たさないpointsは、N個揃っていてもユーザー満足度が低い。

---

## 7. まとめ（"今起きている問題"の核心）

1. **required_points が動的に決まらない**
   - 現状は固定閾値3で判定しているが、本来はN（原文または学生英文の文数）に応じて変わるべき
   - N=5なら5項目、N=2なら2項目が必要
   
2. **LLMが points を少数（1〜2個）で返すのは現行プロンプト上あり得る**
   - プロンプトが「N個返せ」と要求していない
   - LLMは1個だけ返すのが仕様上許容される
   
3. **backend が `len(points) < 3` をトリガに points を"エラー1件"へ強制置換**
   - 固定閾値3という設計がN対応を阻害
   - 置換により既存の有益なpointsが全て失われる（破壊的）
   - UIは必ず **1項目**になり、ユーザーに誤ったエラー表示を出す
   
4. **before 空除外で points が減る可能性があり、N不足が加速する**
   - 除外後に`len(valid_points) < required_points`の再検証が無い
   - 不足分を埋める処理が存在しない
   
5. **UI要件（N文→N項目）と、prompt/backend の points 設計が噛み合っていない**
   - プロンプト：最低1個
   - バックエンド：3未満でエラー
   - UI：N項目（動的）
   - この3つが統一されていない

---

## 8. 修正方針（N対応の実装要件）

### 8-1. required_points の自動決定

1. **原文の文数取得**：日本語原文をピリオド/句点で分割してカウント
2. **フォールバック**：原文が無い場合、学生英文をピリオドで分割してカウント
3. **最終手段**：LLMに意味単位数を判定させる

### 8-2. プロンプト修正

* `required_points=N` をプロンプトにパラメータとして渡す
* 「必ずN個の非「内容評価」pointを返せ」と明示
* 例：「原文は5文です。5個のpointを返してください」

### 8-3. バックエンドのN不足検出・埋め合わせ

* **固定閾値3を撤廃**：`len(points) < required_points` で動的に判定
* **置換ではなく埋め合わせ**：
  1. LLMに再プロンプトで不足分を要求
  2. それでも不足なら、既存pointsを維持しつつ、不足分を埋める（fill）
  3. 既存の有益なpointsは破壊しない
  
### 8-4. before空除外後の再検証

* 除外後に`len(valid_points) < required_points`をチェック
* 不足している場合、再プロンプトで埋め合わせ

---

## 9. テスト要件（N対応の検証観点）

以下のケースで、required_pointsが正しく決定され、N個のpointsが安定して出力されることを確認する。

| テストケース | 原文 | 学生英文 | required_points | 期待される挙動 |
|-------------|------|----------|-----------------|---------------|
| **標準（4文）** | 4文 | 4文 | 4 | 4項目の解説が出る（非「内容評価」） |
| **標準（5文）** | 5文 | 5文 | 5 | 5項目の解説が出る |
| **標準（3文）** | 3文 | 3文 | 3 | 3項目の解説が出る |
| **要約（5→3）** | 5文 | 3文 | 5 | 5項目の解説が出る（統合した旨をreasonで説明） |
| **要約（4→2）** | 4文 | 2文 | 4 | 4項目の解説が出る（統合した旨をreasonで説明） |
| **統合（2→1）** | 2文 | 1文 | 2 | 2項目の解説が出る（前半/後半で分割） |
| **原文なし** | なし | 3文 | 3 | 3項目の解説が出る（学生英文基準） |
| **原文なし** | なし | 5文 | 5 | 5項目の解説が出る（学生英文基準） |

### 9-1. 各テストケースの確認項目

1. **項目数**：`data.points.filter(p => p.level !== "内容評価").length === required_points`
2. **エラー表示の回避**：「添削処理中にエラーが発生しました」という固定文言が出ないこと
3. **解説品質**：各pointのreasonが6章の形式を満たしていること（語彙比較＋【参考】＋例文2つ）
4. **before/afterの妥当性**：beforeが空でないこと、afterが改善を示していること

### 9-2. エッジケースの確認

| エッジケース | 期待される挙動 |
|-------------|---------------|
| LLMが1個しか返さない | 再プロンプトでrequired_points個を要求、不足分を埋める |
| beforeが空のpointが混在 | 除外後に不足検出→再プロンプトで埋め合わせ |
| N=1（原文1文） | 1項目の解説が出る（エラーにならない） |
| N=10（原文10文） | 10項目の解説が出る（固定閾値3に引っかからない） |

---

## 10. agent にやってほしいこと（= 次段の設計検討に必要な事実収集）

※ここから先は「実装案」ではなく、**仕様確定に必要な"問題点の裏取り"**。

### 10-1. コード根拠の再確認

* [ ] 上記のコード箇所（llm_service.py:1241-1249, 1251-1270 / main.js:482-492）を根拠として、**なぜ 1項目になるのか**を再現ログ付きで説明する
* [ ] 固定閾値3がN対応を阻害している具体例を示す（N=5で4個返った場合など）

### 10-2. LLMの出力パターン調査

* [ ] LLMが points を 1〜2個しか返さないケースを実際に確認（プロンプトがN個を要求していないため）
* [ ] プロンプトに「N個返せ」を追加した場合、LLMが従うかを検証

### 10-3. 文数ズレの再現テスト

* [ ] 文数ズレ（5→3、2→1統合）をテスト入力で再現し、現状の points 出力がどう崩れるかを記録
* [ ] required_points決定ルールを実装した場合、どのように動作するかをシミュレート

### 10-4. 仕様の明文化

* [ ] 「N項目を満たすには、(A) 原文文数ベース / (B) 英文文数ベース / (C) 意味単位ベース」のどれを採用するか、**仕様として決めないと実装できない**点を明文化する
  - → 本レポートでは **(A) 原文文数ベース（優先）** を採用する方針で統一済み
  
### 10-5. 埋め合わせ処理の設計

* [ ] 不足時の埋め合わせ処理（再プロンプト / fill処理）の具体的な実装方針を検討
* [ ] 既存pointsを破壊せずに不足分を追加する方法を設計

---
